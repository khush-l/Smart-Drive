This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: output_files/**/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    python-test.yml
static/
  index.css
  script.js
templates/
  index.html
tests/
  __init__.py
  test_route_safety.py
  test_routes.py
topic_prompts/
  initial_prompt.txt
  voice_route_demo_prompt.txt
--output
.gitignore
app.py
README.md
requirements-test.txt
requirements.txt
Route_Safety.py
testing.ipynb
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="--output">
üì¶ Repomix v0.3.1

No custom config found at repomix.config.json or global config at /home/codespace/.config/repomix/repomix.config.json.
You can add a config file for additional settings. Please check https://github.com/yamadashy/repomix for more information.
‚úñ Error during packing


Need help?
‚Ä¢ File an issue on GitHub: https://github.com/yamadashy/repomix/issues
‚Ä¢ Join our Discord community: https://discord.gg/wNYzTwZFku
</file>

<file path="tests/__init__.py">
# This file makes the tests directory a Python package
</file>

<file path="tests/test_route_safety.py">
import pytest
import numpy as np
import pandas as pd
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from Route_Safety import load_crash_data, identify_crash_hotspots, train_model, calculate_safety_score, get_google_routes
from unittest.mock import patch

@pytest.fixture
def sample_crash_data():
    """Create sample crash data for testing"""
    return pd.DataFrame({
        'latitude': [
            30.2672, 30.2772, 30.2872, 30.2972, 30.3072,  # Different lat bins
            30.3172, 30.3272, 30.3372, 30.3472, 30.3572
        ],
        'longitude': [
            -97.7431, -97.7531, -97.7631, -97.7731, -97.7831,  # Different lng bins
            -97.7931, -97.8031, -97.8131, -97.8231, -97.8331
        ],
        'crash_sev_id': [1, 2, 3, 2, 1, 3, 2, 1, 3, 2],
        'Crash timestamp (US/Central)': [
            '2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05',
            '2023-01-06', '2023-01-07', '2023-01-08', '2023-01-09', '2023-01-10'
        ]
    })

@pytest.fixture
def sample_route():
    """Create a sample route for testing"""
    return {
        'legs': [{
            'duration': {'value': 600},
            'steps': [{
                'end_location': {'lat': 30.2672, 'lng': -97.7431},
                'html_instructions': 'Test step'
            }]
        }]
    }

def test_load_crash_data(sample_crash_data, tmp_path):
    """Test loading crash data"""
    # Save sample data to temporary file
    file_path = tmp_path / "test_data.csv"
    sample_crash_data.to_csv(file_path, index=False)
    
    # Test loading
    loaded_data = load_crash_data(str(file_path))
    assert isinstance(loaded_data, pd.DataFrame)
    assert len(loaded_data) == 10
    assert 'latitude' in loaded_data.columns
    assert 'longitude' in loaded_data.columns

def test_load_crash_data_invalid_file(tmp_path):
    """Test loading crash data with invalid file"""
    with pytest.raises(Exception):
        load_crash_data(str(tmp_path / "nonexistent.csv"))

def test_identify_crash_hotspots(sample_crash_data):
    """Test hotspot identification"""
    hotspots = identify_crash_hotspots(sample_crash_data)
    assert isinstance(hotspots, pd.DataFrame)
    assert 'lat_bin' in hotspots.columns
    assert 'lng_bin' in hotspots.columns
    assert 'crash_sev_id' in hotspots.columns

def test_train_model(sample_crash_data):
    """Test model training"""
    hotspots = identify_crash_hotspots(sample_crash_data)
    model = train_model(hotspots)
    assert model is not None
    # Test prediction
    test_input = np.array([[30.2672, -97.7431]])
    prediction = model.predict(test_input)
    assert isinstance(prediction, np.ndarray)
    assert len(prediction) == 1

def test_calculate_safety_score(sample_route):
    """Test safety score calculation"""
    with patch('Route_Safety.train_model') as mock_model:
        mock_model.return_value.predict.return_value = np.array([2.5])
        score, duration = calculate_safety_score(sample_route, mock_model.return_value)
        assert isinstance(score, float)
        assert isinstance(duration, float)
        assert 1 <= score <= 10
        assert duration > 0

def test_get_google_routes():
    """Test Google Maps API route fetching"""
    with patch('requests.get') as mock_get:
        mock_get.return_value.status_code = 200
        mock_get.return_value.json.return_value = {
            "routes": [{
                "legs": [{
                    "distance": {"text": "10 miles"},
                    "duration": {"value": 600},
                    "steps": [{"html_instructions": "Test step"}]
                }]
            }]
        }
        routes = get_google_routes("test_key", "Austin, TX", "Houston, TX")
        assert isinstance(routes, list)
        assert len(routes) == 1

def test_get_google_routes_error():
    """Test Google Maps API error handling"""
    with patch('requests.get') as mock_get:
        mock_get.return_value.status_code = 400
        routes = get_google_routes("test_key", "Austin, TX", "Houston, TX")
        assert routes == []
</file>

<file path="topic_prompts/initial_prompt.txt">
You are SmartDrive AI Assistant, an informative and helpful chatbot that assists users in understanding how their route is evaluated for safety and how the SmartDrive AI system works.

SmartDrive is an AI-powered route safety tool developed using crash data from Austin, Texas. It uses clustering algorithms (DBSCAN) to detect accident hotspots and assigns a Crash Severity Index to different zones based on crash frequency and severity. A machine learning model (Random Forest Regressor) then predicts the potential risk level for a given route.

Your job is to:
Help users understand how SmartDrive determines whether a route is high-risk or low-risk.
Explain how the clustering and crash severity model works in simple terms if asked.
Answer user questions about how the AI was trained, what kind of data was used, and what makes a zone high-risk.
Provide basic safety suggestions based on the user‚Äôs route (if provided).
Remain clear, concise, and friendly in your explanations.
If unsure about something, explain the limitation and suggest where the user could learn more.

Example questions users may ask:
‚ÄúWhy is this route considered high-risk?‚Äù
‚ÄúHow does your AI figure out which areas are dangerous?‚Äù
‚ÄúCan you explain how your crash data works?‚Äù
‚ÄúWhat makes SmartDrive better than Google Maps?‚Äù

Always respond with helpful and respectful language, even if the question is unclear. Your goal is to educate and assist users while demonstrating the value of the SmartDrive AI system.
</file>

<file path="topic_prompts/voice_route_demo_prompt.txt">
# topic_prompts/voice_route_demo_prompt.txt

### System Message
You are SmartDrive Voice Assistant, a voice‚Äëfirst GPS‚Äëdriven safety companion. For each incoming position update:
- Load crash hotspots from¬†output_files/high_crash_zones.geojson and apply a 50¬†m buffer.
- If the coordinate is inside or within 50¬†m of a hotspot, respond with a concise warning:
  ‚ÄúAlert: High‚Äëcrash zone ahead. Proceed with caution.‚Äù
- Otherwise, respond with a brief navigation update, e.g.:
  ‚ÄúProceed straight for 200¬†meters.‚Äù
- Keep each response under 20 words, plain language, TTS‚Äëfriendly.
- Use deterministic settings (temperature=0, top_p=0.1).
- Output **only** the spoken text (no JSON or markup).

### User Message
Coordinate update:
  latitude: {latitude}
  longitude: {longitude}
Previous coordinate:
  latitude: {prev_latitude}
  longitude: {prev_longitude}
</file>

<file path="tests/test_routes.py">
import pytest
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from app import app
import json
from unittest.mock import patch, MagicMock

@pytest.fixture
def client():
    app.config['TESTING'] = True
    with app.test_client() as client:
        yield client

def test_home_route(client):
    """Test the home route returns a successful response"""
    response = client.get('/')
    assert response.status_code == 200

def test_test_openai_route(client):
    """Test the OpenAI test route returns a successful response"""
    with patch('app.client.chat.completions.create') as mock_create:
        mock_create.return_value = MagicMock(
            choices=[MagicMock(message=MagicMock(content="Hello, testing 1-2-3"))]
        )
        response = client.get('/test_openai')
        # Accept both 200 and 500 status codes since API key might be missing in CI
        assert response.status_code in [200, 500]
        if response.status_code == 200:
            data = json.loads(response.data)
            assert data['status'] == 'success'
            assert data['message'] == "Hello, testing 1-2-3"
        else:
            data = json.loads(response.data)
            assert 'error' in data

def test_analyze_route_missing_params(client):
    """Test analyze_route with missing parameters"""
    response = client.post('/analyze_route', json={})
    assert response.status_code == 400
    data = json.loads(response.data)
    assert 'error' in data
    assert 'Please provide both start and end locations' in data['error']

def test_analyze_route_success(client):
    """Test successful route analysis"""
    with patch('Route_Safety.get_google_routes') as mock_routes:
        mock_routes.return_value = [{
            'legs': [{
                'distance': {'text': '10 miles'},
                'duration': {'value': 600},
                'steps': [{
                    'end_location': {'lat': 30.2672, 'lng': -97.7431},
                    'html_instructions': 'Test step'
                }]
            }]
        }]
        with patch('Route_Safety.calculate_safety_score') as mock_score:
            mock_score.return_value = (8.5, 10.0)
            response = client.post('/analyze_route', json={
                'start': 'Austin, TX',
                'end': 'Houston, TX'
            })
            # Accept both 200 and 404 status codes since API key might be missing in CI
            assert response.status_code in [200, 404]
            if response.status_code == 200:
                data = json.loads(response.data)
                assert 'routes' in data
                assert 'route_details' in data
            else:
                data = json.loads(response.data)
                assert 'error' in data

def test_chat_route(client):
    """Test the chat route"""
    with patch('app.client.chat.completions.create') as mock_create:
        mock_create.return_value = MagicMock(
            choices=[MagicMock(message=MagicMock(content="AI response"))]
        )
        response = client.post('/chat', json={'message': 'Hello'})
        assert response.status_code == 200
        data = json.loads(response.data)
        assert 'response' in data
        assert data['response'] == "AI response"

def test_chat_route_missing_message(client):
    """Test chat route with missing message"""
    response = client.post('/chat', json={})
    assert response.status_code == 400
    data = json.loads(response.data)
    assert 'error' in data
    assert 'No message provided' in data['error']

def test_clear_session(client):
    """Test the clear_session route"""
    response = client.get('/clear_session')
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['status'] == 'session cleared'
</file>

<file path=".gitignore">
# Environment variables
.env
.env.*
!.env.example
*.env
.env.local
.env.development
.env.test
.env.production

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Flask Session
flask_session/
</file>

<file path="requirements-test.txt">
pytest==7.4.0
pytest-cov==4.1.0
requests==2.32.2
pytest-mock==3.12.0
python-dotenv==1.0.0
</file>

<file path="requirements.txt">
flask>=3.0.0
flask-session>=0.6.0
openai>=1.0.0
openai-whisper>=1.0.0  # Added for voice transcription support
pandas>=2.0.0
numpy>=1.24.0
scikit-learn>=1.3.0
geopy>=2.3.0
shapely>=2.0.0
requests>=2.31.0
python-dotenv>=1.0.0
joblib>=1.3.0
Werkzeug>=3.0.0
</file>

<file path=".github/workflows/python-test.yml">
name: Python Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.9]

    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for all branches and tags
    
    - name: Show commit being tested
      run: |
        echo "Testing commit: ${{ github.sha }}"
        git log -1 --pretty=format:"%h %s"
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
        cache: 'pip'
    
    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-test.txt
    
    - name: Run tests with coverage
      run: |
        pytest --cov=app --cov=Route_Safety --cov-report=xml tests/
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        GOOGLE_MAPS_API_KEY: ${{ secrets.GOOGLE_MAPS_API_KEY }}
        FLASK_SECRET_KEY: ${{ secrets.FLASK_SECRET_KEY }}
    
    - name: Upload coverage to Codecov
      if: env.CODECOV_TOKEN != ''
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        fail_ci_if_error: false
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
</file>

<file path="Route_Safety.py">
import pandas as pd
import numpy as np
import json
import requests
import openai
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
from geopy.distance import geodesic
from shapely.geometry import Point, Polygon
from sklearn.preprocessing import StandardScaler
import os
from joblib import dump
from dotenv import load_dotenv

# Force reload environment variables
print("Current working directory:", os.getcwd())
print("Loading .env file...")
load_dotenv(override=True)
print("Environment variables loaded")

# 1. Processing Crash Data and Training the AI Model

def load_crash_data(filename):
    data = pd.read_csv(filename, low_memory=False)
    data = data[['latitude', 'longitude', 'crash_sev_id', 'Crash timestamp (US/Central)']].dropna()
    return data


def identify_crash_hotspots(data, grid_size=0.01):
    data['lat_bin'] = (data['latitude'] // grid_size) * grid_size
    data['lng_bin'] = (data['longitude'] // grid_size) * grid_size

    hotspot_severity = data.groupby(['lat_bin', 'lng_bin'])['crash_sev_id'].mean().reset_index()
    return hotspot_severity


def train_model(hotspot_data):
    X = hotspot_data[['lat_bin', 'lng_bin']]
    y = hotspot_data['crash_sev_id']

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    model = RandomForestRegressor(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)

    y_pred = model.predict(X_test)
    mse = mean_squared_error(y_test, y_pred)
    print(f'Mean Squared Error on test data: {mse}')

    model_file_path = 'trainedModel.joblib'
    dump(model, model_file_path)
    print(f"Model saved to {model_file_path}")
    return model


# 2. Fetching Routes and Evaluating with AI Model

def get_google_routes(api_key, origin, destination):
    """
    Fetch driving routes (including alternatives) from Google Directions API
    and log both HTTP and API-level status messages for debugging.
    """
    base_url = "https://maps.googleapis.com/maps/api/directions/json"
    params = {
        "origin":      origin,
        "destination": destination,
        "mode":        "driving",
        "alternatives": "true",
        "key":         api_key
    }

    response = requests.get(base_url, params=params)

    try:
        data = response.json()
    except ValueError:
        print(f"Failed to parse JSON (HTTP {response.status_code}): {response.text}")
        return []

    api_status = data.get("status")
    error_message = data.get("error_message")
    print(f"Google Maps API status: {api_status}")
    if error_message:
        print(f"Google Maps error_message: {error_message}")

    if response.status_code == 200 and api_status == "OK":
        routes = data.get("routes", [])
        print(f"Found {len(routes)} route options.")
        return routes
    else:
        print(f"Directions request failed: HTTP {response.status_code}, API status = {api_status}")
        return []


def calculate_safety_score(route, model):
    scores = []
    total_duration = 0

    for leg in route['legs']:
        total_duration += leg['duration']['value'] / 60  # minutes
        for step in leg['steps']:
            lat = step['end_location']['lat']
            lng = step['end_location']['lng']
            df = pd.DataFrame([[lat, lng]], columns=['lat_bin', 'lng_bin'])
            safety_score = model.predict(df)[0]
            scores.append(safety_score)

    avg_score = np.mean(scores) if scores else 0
    return min(max(10 - avg_score, 1), 10), total_duration


# --- New voice-first functionality ---

def load_hotspot_polygons(geojson_path="output_files/high_crash_zones.geojson"):
    """
    Load crash-hotspot polygons from a GeoJSON file.
    """
    polygons = []
    try:
        with open(geojson_path) as f:
            gj = json.load(f)
        for feat in gj.get("features", []):
            coords = feat["geometry"]["coordinates"][0]
            poly = Polygon([(lng, lat) for lat, lng in coords])
            polygons.append(poly)
    except Exception as e:
        print(f"Error loading hotspot polygons: {e}")
    return polygons

# Pre-load hotspot polygons once
_HOTSPOT_POLYGONS = load_hotspot_polygons()


def is_in_hotspot(lat, lng, buffer_m=50):
    """
    Check if a coordinate lies within or near (buffer_m) any crash-hotspot polygon.
    """
    buffer_deg = buffer_m / 111320.0  # approximate meters to degrees
    point = Point(lng, lat)
    for poly in _HOTSPOT_POLYGONS:
        if poly.buffer(buffer_deg).contains(point):
            return True
    return False


def generate_voice_update(lat, lng, prev_lat, prev_lng, model_name="gpt-3.5-turbo"):
    """
    Generate a concise, TTS-friendly voice update for the given coordinate.
    If within a hotspot, return a warning immediately; otherwise, call the LLM.
    """
    openai.api_key = os.getenv("OPENAI_API_KEY")

    # Pre-check crash zone
    if is_in_hotspot(lat, lng):
        return "Alert: High‚Äëcrash zone ahead. Proceed with caution."

    # Read and split the prompt template
    prompt_file = "topic_prompts/voice_route_demo_prompt.txt"
    with open(prompt_file) as f:
        content = f.read()
    system_part, user_part = content.split("### User Message")
    system_content = system_part.replace("### System Message", "").strip()
    user_template = user_part.strip()

    # Fill in dynamic coordinates
    user_content = user_template.format(
        latitude=lat,
        longitude=lng,
        prev_latitude=prev_lat,
        prev_longitude=prev_lng
    )

    messages = [
        {"role": "system", "content": system_content},
        {"role": "user",   "content": user_content}
    ]

    resp = openai.chat.completions.create(
        model=model_name,
        messages=messages,
        temperature=0,
        top_p=0.1
    )
    return resp.choices[0].message.content.strip()

# --- End voice-first functionality ---

# Putting it all together

def main():
    try:
        with open('.env', 'r') as f:
            for line in f:
                if line.startswith('GOOGLE_MAPS_API_KEY='):
                    api_key = line.strip().split('=')[1]
                    break
    except Exception as e:
        print(f"Error reading .env file: {e}")
        api_key = os.getenv('GOOGLE_MAPS_API_KEY')

    print(f"Loaded API key: {api_key}")
    print(f"Loaded API key length: {len(api_key) if api_key else 0}")
    print(f"API key starts with: {api_key[:5] if api_key else 'None'}")

    if not api_key:
        raise ValueError("GOOGLE_MAPS_API_KEY environment variable is not set. Please check your .env file.")
    if api_key == "your_api_key_here":
        raise ValueError("You still have the placeholder API key in your .env file. Please replace it with your actual API key.")

    crash_data_file = 'data.csv'
    data = load_crash_data(crash_data_file)
    hotspot_data = identify_crash_hotspots(data)
    model = train_model(hotspot_data)

    routes = get_google_routes(api_key, "Austin, TX", "Houston, TX")
    safety_scores_and_times = [calculate_safety_score(route, model) for route in routes]

    for i, (route, (score, duration)) in enumerate(zip(routes, safety_scores_and_times)):
        print(f"Route {i + 1}: Safety Score {score:.2f}/10, Estimated Time: {duration:.2f} mins")
        print("Route Summary:")
        for leg in route['legs']:
            for step in leg['steps'][:3]:
                print(f"  - {step['html_instructions']} ({step['distance']['text']}, {step['duration']['text']})")
            print("...")

    safest_route_idx = np.argmax([score for score, _ in safety_scores_and_times])
    print(f"Safest Route: {safest_route_idx + 1} with Safety Score: {safety_scores_and_times[safest_route_idx][0]:.2f}/10, Estimated Time: {safety_scores_and_times[safest_route_idx][1]:.2f} mins")


if __name__ == "__main__":
    main()
</file>

<file path="testing.ipynb">
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mean Squared Error on test data: 0.32457581361893867\n",
      "Found 3 route options.\n",
      "Route 1: Safety Score 6.68/10\n",
      "Route Summary:\n",
      "  - Head <b>east</b> on <b>E 5th St.</b> toward <b>Brazos St</b> (0.5 mi, 3 mins)\n",
      "  - Turn <b>right</b> onto <b>S I-35 Frontage Rd</b> (177 ft, 1 min)\n",
      "  - Slight <b>left</b> toward <b>N Interstate 35 Frontage Rd</b> (381 ft, 1 min)\n",
      "...\n",
      "Route 2: Safety Score 6.52/10\n",
      "Route Summary:\n",
      "  - Head <b>east</b> on <b>E 5th St.</b> toward <b>Brazos St</b> (0.5 mi, 3 mins)\n",
      "  - Turn <b>right</b> onto <b>S I-35 Frontage Rd</b> (177 ft, 1 min)\n",
      "  - Slight <b>left</b> toward <b>N Interstate 35 Frontage Rd</b> (381 ft, 1 min)\n",
      "...\n",
      "Route 3: Safety Score 6.86/10\n",
      "Route Summary:\n",
      "  - Head <b>east</b> on <b>E 5th St.</b> toward <b>Brazos St</b> (410 ft, 1 min)\n",
      "  - Turn <b>right</b> onto <b>Brazos St</b> (358 ft, 1 min)\n",
      "  - Turn <b>right</b> onto <b>E 4th St</b> (436 ft, 1 min)\n",
      "...\n",
      "Safest Route: 3 with Safety Score: 6.86/10\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n",
      "/Users/khushl/Documents/GitHub/Smart-Drive/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:2739: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names\n",
      "  warnings.warn(\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import json\n",
    "import requests\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.metrics import mean_squared_error\n",
    "from geopy.distance import geodesic\n",
    "from shapely.geometry import Point, Polygon\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "import os\n",
    "\n",
    "# 1. Processing Crash Data and Training the AI Model\n",
    "\n",
    "def load_crash_data(filename):\n",
    "    data = pd.read_csv(filename, low_memory=False)\n",
    "    data = data[['latitude', 'longitude', 'crash_sev_id', 'Crash timestamp (US/Central)']].dropna()\n",
    "    return data\n",
    "\n",
    "\n",
    "def identify_crash_hotspots(data, grid_size=0.01):\n",
    "    data['lat_bin'] = (data['latitude'] // grid_size) * grid_size\n",
    "    data['lng_bin'] = (data['longitude'] // grid_size) * grid_size\n",
    "\n",
    "    hotspot_severity = data.groupby(['lat_bin', 'lng_bin'])['crash_sev_id'].mean().reset_index()\n",
    "    return hotspot_severity\n",
    "\n",
    "\n",
    "def train_model(hotspot_data):\n",
    "    X = hotspot_data[['lat_bin', 'lng_bin']]\n",
    "    y = hotspot_data['crash_sev_id']\n",
    "\n",
    "    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n",
    "\n",
    "    model = RandomForestRegressor(n_estimators=100, random_state=42)\n",
    "    model.fit(X_train, y_train)\n",
    "\n",
    "    y_pred = model.predict(X_test)\n",
    "    mse = mean_squared_error(y_test, y_pred)\n",
    "    print(f'Mean Squared Error on test data: {mse}')\n",
    "\n",
    "    return model\n",
    "\n",
    "\n",
    "# 2. Fetching Routes and Evaluating with AI Model\n",
    "\n",
    "def get_google_routes(api_key):\n",
    "    base_url = \"https://maps.googleapis.com/maps/api/directions/json\"\n",
    "    params = {\n",
    "        \"origin\": \"Austin, TX\",\n",
    "        \"destination\": \"Houston, TX\",\n",
    "        \"mode\": \"driving\",\n",
    "        \"alternatives\": \"true\",\n",
    "        \"key\": api_key\n",
    "    }\n",
    "\n",
    "    response = requests.get(base_url, params=params)\n",
    "\n",
    "    if response.status_code == 200:\n",
    "        routes = response.json().get(\"routes\", [])\n",
    "        print(f\"Found {len(routes)} route options.\")\n",
    "        return routes\n",
    "    else:\n",
    "        print(f\"Error: {response.status_code} - {response.text}\")\n",
    "        return []\n",
    "\n",
    "\n",
    "def calculate_safety_score(route, model):\n",
    "    scores = []\n",
    "    total_duration = 0\n",
    "\n",
    "    for leg in route['legs']:\n",
    "        total_duration += leg['duration']['value'] / 60  # Convert to minutes\n",
    "        for step in leg['steps']:\n",
    "            lat = step['end_location']['lat']\n",
    "            lng = step['end_location']['lng']\n",
    "            safety_score = model.predict(np.array([[lat, lng]]))[0]\n",
    "            scores.append(safety_score)\n",
    "\n",
    "    avg_score = np.mean(scores) if scores else 0\n",
    "    return min(max(10 - avg_score, 1), 10), total_duration\n",
    "\n",
    "\n",
    "# Putting it all together\n",
    "\n",
    "def main():\n",
    "    api_key = input(\"Enter your Google Maps API key: \")\n",
    "    crash_data_file = 'data.csv'\n",
    "\n",
    "    data = load_crash_data(crash_data_file)\n",
    "    hotspot_data = identify_crash_hotspots(data)\n",
    "    model = train_model(hotspot_data)\n",
    "\n",
    "    routes = get_google_routes(api_key)\n",
    "    \n",
    "    safety_scores_and_times = [calculate_safety_score(route, model) for route in routes]\n",
    "    \n",
    "    for i, (route, (score, duration)) in enumerate(zip(routes, safety_scores_and_times)):\n",
    "        print(f\"Route {i + 1}: Safety Score {score:.2f}/10, Estimated Time: {duration:.2f} mins\")\n",
    "        print(\"Route Summary:\")\n",
    "        for leg in route['legs']:\n",
    "            for step in leg['steps'][:3]:  # Show first few steps for brevity\n",
    "                print(f\"  - {step['html_instructions']} ({step['distance']['text']}, {step['duration']['text']})\")\n",
    "            print(\"...\")\n",
    "\n",
    "    safest_route_idx = np.argmax([score for score, _ in safety_scores_and_times])\n",
    "    print(f\"Safest Route: {safest_route_idx + 1} with Safety Score: {safety_scores_and_times[safest_route_idx][0]:.2f}/10, Estimated Time: {safety_scores_and_times[safest_route_idx][1]:.2f} mins\")\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "venv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
</file>

<file path="static/index.css">
/* 
 * Smart Drive AI - Main Stylesheet
 * Defines the visual styling and layout of the application
 */

/* General page layout and background */
body {
    font-family: Arial, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    background-image: url('https://thumbs.dreamstime.com/b/sunrise-view-futuristic-city-skyline-empty-road-captivating-over-featuring-leading-distance-sky-adorned-351912384.jpg');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
}

/* Main container styling - white card with shadow */
#container {
    background-color: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    width: 90%;
    max-width: 800px;
    margin: 20px;
}

/* Page header styling */
h1 {
    text-align: center;
    color: #333;
    margin-bottom: 20px;
}

/* Input fields section styling */
#input-fields {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-bottom: 20px;
}

#input-fields label {
    font-weight: bold;
    color: #555;
}

#input-fields input {
    padding: 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 16px;
}

/* Map container styling */
#map-container {
    height: 400px;
    margin-bottom: 20px;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid #ccc;
    transition: opacity 0.3s ease;
}

#map {
    height: 100%;
    width: 100%;
}

/* Chat container styling */
#chat-container {
    height: 200px;
    overflow-y: auto;
    border: 1px solid #ccc;
    margin-bottom: 15px;
    padding: 15px;
    background-color: #f9f9f9;
    border-radius: 8px;
}

/* Chat message styling */
.message {
    max-width: 80%;
    margin-bottom: 10px;
    padding: 12px;
    border-radius: 10px;
    word-wrap: break-word;
    font-size: 14px;
    line-height: 1.4;
    position: relative;
    clear: both;
}

/* User message styling */
.user-message {
    background-color: #007bff;
    color: white;
    float: right;
    border-bottom-right-radius: 4px;
    margin-left: 20%;
}

/* Bot message styling */
.bot-message {
    background-color: #e9ecef;
    color: #333;
    float: left;
    border-bottom-left-radius: 4px;
    margin-right: 20%;
}

/* Input container styling */
#input-container {
    display: flex;
    gap: 10px;
}

#user-input {
    flex-grow: 1;
    padding: 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 16px;
}

/* Button styling */
button {
    padding: 12px 20px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s;
    font-size: 16px;
    font-weight: bold;
}

button:hover {
    background-color: #0056b3;
}

/* Loading state styling */
.loading {
    opacity: 0.5;
    pointer-events: none;
}

/* Responsive design for mobile devices */
@media (max-width: 600px) {
    #container {
        width: 95%;
        margin: 10px;
        padding: 15px;
    }

    #map-container {
        height: 300px;
    }

    .message {
        max-width: 90%;
    }
}
</file>

<file path="static/script.js">
/**
 * Smart Drive AI - Main JavaScript File
 * Handles map initialization, route finding, chat, and voice-first streaming
 */

// Global variables for map functionality
let map;                    // Google Maps instance
let directionsService;      // Google Maps Directions Service
let directionsRenderer;     // Google Maps Directions Renderer

/**
 * Initialize the Google Map
 * Called automatically when the Google Maps API loads
 */
window.initMap = function() {
    map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 30.2672, lng: -97.7431 }, // Austin coordinates
        zoom: 12
    });
    directionsService = new google.maps.DirectionsService();
    directionsRenderer = new google.maps.DirectionsRenderer({ map: map });
};

/**
 * Display a route on the map
 * @param {Object} route - The route data from Google Maps API
 */
function displayRoute(route) {
    if (!route || !route.legs || route.legs.length === 0) {
        console.error('Invalid route data');
        return;
    }
    const request = {
        origin: route.legs[0].start_address,
        destination: route.legs[0].end_address,
        travelMode: 'DRIVING'
    };
    directionsService.route(request, function(result, status) {
        if (status === 'OK') {
            directionsRenderer.setDirections(result);
        } else {
            console.error('Directions request failed:', status);
        }
    });
}

/**
 * Display route details in the chat container
 * @param {Array} routeDetails - Array of route detail objects
 */
function displayRouteDetails(routeDetails) {
    const chatContainer = document.getElementById('chat-container');
    chatContainer.innerHTML = '';  // Clear previous
    routeDetails.forEach((detail, index) => {
        const message = `Route ${index + 1}:\n` +
                        `Safety Score: ${detail.safety_score}/10\n` +
                        `Duration: ${detail.duration} minutes\n` +
                        `Distance: ${detail.distance}\n` +
                        `First steps:\n${detail.steps.join('\n')}`;
        addMessageToChat(message, 'bot');
    });
}

/**
 * Find the safest route between two locations
 * Makes API call to backend and displays results
 */
function findSafeRoute() {
    const startLocation = document.getElementById('start-location').value;
    const endLocation = document.getElementById('end-location').value;
    if (!startLocation || !endLocation) {
        alert('Please enter both start and end locations');
        return;
    }
    document.getElementById('map-container').style.opacity = '0.5';
    fetch('/analyze_route', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ start: startLocation, end: endLocation })
    })
    .then(response => response.ok ? response.json() : response.json().then(err => { throw err; }))
    .then(data => {
        if (data.routes && data.routes.length > 0) displayRoute(data.routes[0]);
        if (data.route_details) displayRouteDetails(data.route_details);
    })
    .catch(error => {
        console.error('Error:', error);
        alert(error.error || error);
    })
    .finally(() => {
        document.getElementById('map-container').style.opacity = '1';
    });
}

// Main prediction loop (legacy Teachable Machine code)
async function loop() {
    webcam.update();
    await predict();
    window.requestAnimationFrame(loop);
}

// Predict function (legacy Teachable Machine code)
async function predict() {
    const prediction = await model.predict(webcam.canvas);
    for (let i = 0; i < maxPredictions; i++) {
        const classPrediction = prediction[i].className + ": " + prediction[i].probability.toFixed(2);
        labelContainer.childNodes[i].innerHTML = classPrediction;
        if (prediction[i].probability > 0.5) {
            currentAnimal = prediction[i].className;
        }
    }
}

/**
 * Send a message to the AI chat
 * Handles user input and displays responses
 */
function sendMessage() {
    const userInput = document.getElementById('user-input');
    const message = userInput.value.trim();
    if (message === '') return;
    userInput.disabled = true;
    const sendButton = document.querySelector('#input-container button');
    sendButton.disabled = true;
    sendButton.textContent = 'Sending...';

    addMessageToChat(message, 'user');
    userInput.value = '';

    fetch('/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: message })
    })
    .then(response => response.ok ? response.json() : response.json().then(err => { throw err; }))
    .then(data => {
        if (data.error) {
            console.error('Server error:', data.error);
            addMessageToChat('Error: ' + data.error, 'bot');
        } else {
            addMessageToChat(data.response, 'bot');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        addMessageToChat('Error: ' + (error.error || error), 'bot');
    })
    .finally(() => {
        userInput.disabled = false;
        sendButton.disabled = false;
        sendButton.textContent = 'Send';
        userInput.focus();
    });
}

/**
 * Add a message to the chat container
 * @param {string} message - The message text
 * @param {string} sender - 'user' or 'bot'
 */
function addMessageToChat(message, sender) {
    const chatContainer = document.getElementById('chat-container');
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', sender + '-message');
    messageElement.innerHTML = message.replace(/\n/g, '<br>');
    chatContainer.appendChild(messageElement);
    messageElement.scrollIntoView({ behavior: 'smooth', block: 'end' });
}

/**
 * Start voice-first streaming of updates via SSE-like fetch
 */
async function startVoiceRoute() {
    const startLocation = document.getElementById('start-location').value;
    const endLocation = document.getElementById('end-location').value;
    if (!startLocation || !endLocation) {
        alert('Please enter both start and end locations for voice route');
        return;
    }
    document.getElementById('map-container').style.opacity = '0.5';
    try {
        const response = await fetch('/stream_route', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ start: startLocation, end: endLocation })
        });
        if (!response.ok) {
            const err = await response.json();
            throw new Error(err.error || 'Stream failed');
        }
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            const parts = buffer.split('\n\n');
            buffer = parts.pop();
            for (const part of parts) {
                if (part.startsWith('data: ')) {
                    try {
                        const packet = JSON.parse(part.slice(6));
                        handleVoicePacket(packet);
                    } catch (e) {
                        console.error('Parse SSE data', e);
                    }
                }
            }
        }
    } catch (error) {
        console.error('Voice stream error', error);
        alert('Voice stream error: ' + error.message);
    } finally {
        document.getElementById('map-container').style.opacity = '1';
    }
}

/**
 * Handle each streamed packet: display and speak
 * @param {Object} packet - { text, latitude, longitude }
 */
function handleVoicePacket(packet) {
    const text = packet.text;
    addMessageToChat(text, 'bot');
    const utterance = new SpeechSynthesisUtterance(text);
    speechSynthesis.speak(utterance);
}

/**
 * DOM loaded: bind event listeners
 */
document.addEventListener('DOMContentLoaded', function() {
    // Text-based route button (if given an ID)
    const startBtn = document.getElementById('start-button');
    if (startBtn) startBtn.addEventListener('click', findSafeRoute);
    // Voice-based route button
    const voiceBtn = document.getElementById('voice-button');
    if (voiceBtn) voiceBtn.addEventListener('click', startVoiceRoute);

    const userInput = document.getElementById('user-input');
    const sendBtn = document.querySelector('#input-container button');
    userInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    sendBtn.addEventListener('click', sendMessage);

    // Initial welcome message
    addMessageToChat("Hello! I'm your Smart Drive AI assistant. I can help you find safe routes and provide voice updates. How can I help you today?", 'bot');
});
</file>

<file path="templates/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Drive AI</title>
    
    <!-- Link to custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='index.css') }}">
    
    <!-- Initialize initMap function before loading Google Maps API -->
    <script>
        // Define initMap in the global scope before loading the API
        window.initMap = function() {
            // This will be overridden by the actual implementation in script.js
            console.log('Map initialization started');
        };

        // Function to load Google Maps API
        function loadGoogleMapsAPI() {
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key={{ google_maps_api_key }}&callback=initMap&libraries=places,directions`;
            script.async = true;
            script.defer = true;
            script.onerror = function() {
                console.error('Failed to load Google Maps API');
            };
            document.head.appendChild(script);
        }

        // Load the API when the DOM is ready
        document.addEventListener('DOMContentLoaded', loadGoogleMapsAPI);
    </script>
</head>
<body>
    <!-- Main container for all content -->
    <div id="container">
        <!-- Page header -->
        <h1>AI Smart Drive</h1>

        <!-- User input section for route planning -->
        <div id="input-fields">
            <label for="start-location">Current Location:</label>
            <input type="text" id="start-location" placeholder="Enter your current location">
            
            <label for="end-location">Destination:</label>
            <input type="text" id="end-location" placeholder="Enter your destination">
            
            <button id="start-button" onclick="findSafeRoute()">Find Safe Route</button>
            <button id="voice-button" onclick="startVoiceRoute()">Start Voice Route</button>

            <label for="voice-file">Upload Voice Command:</label>
            <input type="file" id="voice-file" accept="audio/*">
            <button id="voice-upload-button">Send Voice Command</button>
        </div>

        <!-- Map container with loading indicator -->
        <div id="map-container">
            <div id="map">
                <div id="map-loading" style="display: none;">
                    Loading map...
                </div>
            </div>
        </div>

        <!-- Chat interface for AI assistant -->
        <div id="chat-container"></div>
        <div id="input-container">
            <input type="text" id="user-input" placeholder="Ask about a route...">
            <button onclick="sendMessage()">Send</button>
        </div>
    </div>

    <!-- Load main JavaScript file -->
    <script src="{{ url_for('static', filename='script.js') }}"></script>
</body>
</html>
</file>

<file path="app.py">
from flask import Flask, render_template, request, jsonify, session, Response
from flask_session import Session
import openai
import os
from dotenv import load_dotenv
from Route_Safety import (
    get_google_routes,
    calculate_safety_score,
    train_model,
    identify_crash_hotspots,
    load_crash_data,
    generate_voice_update
)
import logging
import json

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Load environment variables from .env file
load_dotenv()

# Initialize Flask application
app = Flask(__name__)

# Configure session management
app.config["SESSION_PERMANENT"] = False
app.config["SESSION_TYPE"] = "filesystem"
Session(app)

# API Keys from environment
openai.api_key = os.getenv('OPENAI_API_KEY')
google_maps_api_key = os.getenv('GOOGLE_MAPS_API_KEY')

# Voice & transcription model configs
VOICE_MODEL = os.getenv('VOICE_MODEL', 'gpt-3.5-turbo')
WHISPER_MODEL = os.getenv('WHISPER_MODEL', 'whisper-1')

# Initialize the safety model on startup
print("Loading crash data and training model...")
crash_data = load_crash_data('data.csv')
hotspot_data = identify_crash_hotspots(crash_data)
safety_model = train_model(hotspot_data)
print("Model training complete!")

@app.route('/')
def home():
    return render_template('index.html', google_maps_api_key=google_maps_api_key)

@app.route('/analyze_route', methods=['POST'])
def analyze_route():
    data = request.json
    start_location = data.get('start')
    end_location = data.get('end')
    if not start_location or not end_location:
        return jsonify({'error': 'Please provide both start and end locations'}), 400
    try:
        routes = get_google_routes(google_maps_api_key, start_location, end_location)
        if not routes:
            return jsonify({'error': 'No routes found between the specified locations'}), 404
        route_details = []
        for route in routes:
            score, duration = calculate_safety_score(route, safety_model)
            route_details.append({
                'safety_score': score,
                'duration': duration,
                'distance': route['legs'][0]['distance']['text'],
                'steps': [step['html_instructions'] for step in route['legs'][0]['steps'][:3]]
            })
        return jsonify({'routes': routes, 'route_details': route_details})
    except Exception as e:
        logger.error(f"Error analyzing route: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/stream_route', methods=['POST'])
def stream_route():
    """
    Stream voice-first driving updates via Server-Sent Events.
    Accepts JSON with either:
      - 'gps_sequence': list of {latitude, longitude}
      - or 'start' and 'end' to fetch a route and extract step coordinates.
    """
    data = request.json or {}
    gps_sequence = data.get('gps_sequence')
    if not gps_sequence:
        start = data.get('start')
        end = data.get('end')
        if not start or not end:
            return jsonify({'error': 'Provide gps_sequence or start and end locations'}), 400
        routes = get_google_routes(google_maps_api_key, start, end)
        if not routes:
            return jsonify({'error': 'No routes found'}), 404
        gps_sequence = [
            {'latitude': step['end_location']['lat'], 'longitude': step['end_location']['lng']}
            for step in routes[0]['legs'][0]['steps']
        ]

    def event_stream():
        prev = gps_sequence[0]
        for coord in gps_sequence:
            lat = coord['latitude']
            lng = coord['longitude']
            update = generate_voice_update(lat, lng, prev['latitude'], prev['longitude'], model_name=VOICE_MODEL)
            data_packet = {'text': update, 'latitude': lat, 'longitude': lng}
            yield f"data: {json.dumps(data_packet)}\n\n"
            prev = coord

    return Response(event_stream(), mimetype='text/event-stream')

@app.route('/voice_input', methods=['POST'])
def voice_input():
    """
    Transcribe uploaded audio via Whisper and return the transcript.
    """
    if 'file' not in request.files:
        return jsonify({'error': 'No audio file part'}), 400
    file = request.files['file']
    try:
        transcript_resp = openai.Audio.transcribe(
            model=WHISPER_MODEL,
            file=file
        )
        text = transcript_resp.get('text', '')
        return jsonify({'transcript': text})
    except Exception as e:
        logger.error(f"Whisper transcription failed: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/test_openai', methods=['GET'])
def test_openai():
    try:
        logger.debug("Testing OpenAI API connection")
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": "Say 'Hello, testing'"}],
            max_tokens=20
        )
        return jsonify({
            'status': 'success',
            'message': response.choices[0].message.content,
            'api_key_set': bool(openai.api_key)
        })
    except Exception as e:
        logger.error(f"OpenAI test failed: {e}")
        return jsonify({'status':'error','error':str(e)}),500

@app.route('/chat', methods=['POST'])
def chat():
    try:
        user_message = request.json.get('message')
        if not user_message:
            return jsonify({'error':'No message provided'}),400
        if 'conversation' not in session:
            session['conversation'] = []
        try:
            with open('topic_prompts/initial_prompt.txt') as f:
                initial_prompt = f.read()
        except FileNotFoundError:
            return jsonify({'error':'Initial prompt file not found'}),500
        messages = [{"role":"system","content":initial_prompt}]
        messages += session['conversation'][-10:]
        messages.append({"role":"user","content":user_message})
        resp = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=messages,
            temperature=0.7,
            max_tokens=500
        )
        gpt_content = resp.choices[0].message.content
        session['conversation'].append({"role":"assistant","content":gpt_content})
        session.modified = True
        return jsonify({'response':gpt_content})
    except Exception as e:
        logger.error(f"Chat endpoint error: {e}")
        return jsonify({'error':str(e)}),500

@app.route('/clear_session', methods=['GET'])
def clear_session():
    session.clear()
    return jsonify({'status':'session cleared'})

if __name__ == '__main__':
    app.run(host="0.0.0.0", port=8080)
</file>

<file path="README.md">
# Smart Drive

A route safety analysis tool that uses an ML model to evaluate the safety of different driving routes.


## Features

- Real-time route safety analysis using historical crash data
- Multiple route options with safety scores
- AI-powered chat assistant for route recommendations
- Interactive map interface
- Crash hotspot identification
- Estimated travel times and distances
- Route step-by-step instructions

## Setup

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/Smart-Drive.git
   cd Smart-Drive
   ```

2. Create and activate a virtual environment:
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

3. Install the required packages:
   ```bash
   pip install -r requirements.txt
   ```

4. Get your API keys:
   - **Google Maps API Key**:
     - Go to [Google Cloud Console](https://console.cloud.google.com/)
     - Create a new project or select an existing one
     - Enable the Directions API
     - Create an API key in Credentials
   
   - **OpenAI API Key**:
     - Go to [OpenAI Platform](https://platform.openai.com/)
     - Create an account or sign in
     - Generate an API key in your account settings

5. Set up your environment variables:
   - Copy `.env.example` to `.env`:
     ```bash
     cp .env.example .env
     ```
   - Open `.env` and add your API keys:
     ```
     GOOGLE_MAPS_API_KEY=your_google_maps_api_key
     OPENAI_API_KEY=your_openai_api_key

     ```

## Usage

1. Start the Flask application:
   ```bash
   python app.py
   ```

2. Open your web browser and navigate to:
   ```
   http://localhost:8080
   ```

3. Enter your starting and destination locations to get route analysis.

## Important Notes

- The application requires both Google Maps API and OpenAI API keys
- Google Maps API has a free tier with generous limits for personal use
- OpenAI API usage is billed based on token usage
- Never share your API keys or commit them to version control
- The `.env` file is already in `.gitignore` to prevent accidental commits

## Project Structure

```
Smart-Drive/
‚îú‚îÄ‚îÄ app.py                 # Main Flask application
‚îú‚îÄ‚îÄ Route_Safety.py        # Route analysis and safety scoring
‚îú‚îÄ‚îÄ requirements.txt       # Python dependencies
‚îú‚îÄ‚îÄ static/               # Static files (CSS, JS)
‚îú‚îÄ‚îÄ templates/            # HTML templates
‚îú‚îÄ‚îÄ topic_prompts/        # AI chat prompts
‚îú‚îÄ‚îÄ trainedModel.joblib   # Trained safety model
‚îî‚îÄ‚îÄ data.csv             # Historical crash data
```

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request
<<<<<<< HEAD
=======


>>>>>>> 05e0e97f09a5de4a5431905e2e75b4864b7399e4
</file>

</files>
